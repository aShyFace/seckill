# 1 超买问题
问题描述：
1. mybatisplus自带函数无法满足秒杀业务，但是其提供的update会返回更新数据条数。数据条数是否更新等价于是否抢到券，**没有该信息会出现超买现象**。
2. 教程提供的代码中，直接在service中编写sql语句，增加了代码的耦合性——如果表字段发生改变，service代码也需要进行更改。

解决：
1. 自定义的mapper.xml需要添加 SELECT ROW_COUNT(); 返回更新数据条数。
2. 同时需要在配置文件中（jdbcurl）开启 allowMultiQueries=true。
<br/><br/><br/>



# 2 synchronized在@transactional所在方法内部使用，导致的并发问题
场景：实现秒杀优惠券一人一单时，在查询订单数量之后 spring提交事务之前，会出现超买问题（并发问题）。解决方法是添加synchronized，也就是悲观锁，但还是出了问题。
>乐观锁是基于“版本号”实现的，也就是要求操作的时候数据必须存在，即，只能在update的时候使用。该业务是添加订单，insert操作，用不了乐观锁

原因：@transactional由spring管理，整个方法执行完后才会提交事务。synchronized修饰的代码块执行后，就会自动释放锁。导致 **synchronized执行后，@transactional提交前** 这段时间，其它线程有机会访问代码，导致依然会出现超买现象。

解决：
1. synchronized不能加在方法上，应该加在调用者的那行代码上。加在方法上是 先释放锁，在提交事务（会出现多线程问题）；加在调用者上是 先提交事务（因为方法执行结束后@transactional就提交了），再释放锁  
2. 调用这个方法的代码，需要使用代理对象来调用这个方法。即
```
    VoucherOrderService proxy = (VoucherOrderService) AopContext.currentProxy();
    // createVoucherOrder默认是 this.createVoucherOrder，代理对象不能用this
    proxy.createVoucherOrder(voucherId); 
```
<br/><br/><br/>




