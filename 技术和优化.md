# 1 业务优化
## 1.1 集群session共享问题
### 描述
多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题
业务流程：
1. 用户填写手机号，**点击**获取验证码，后端生成随机验证码返回，同时把 手机号-验证码 的对应关系保存到session
2. 用户提交手机号和验证码，后端根据手机号判断用户是否存在，存在则保存用户信息到session中；否则转到登陆界面或直接创建新用户
3. 之后用户再次登陆，后端则根据cookie中保存的sessionid获取用户信息，若有则放行

### 方案
session的替代方案应该满足
- 数据共享
- 内存存储
- key、value结构

使用redis存储后的流程：
1. 用户填写手机号，点击获取验证码，后端生成随机验证码返回，同时把 手机号-验证码 的对应关系保存到redis
2. 用户提交手机号和验证码，**后端根据第1步存入的 手机号-验证码 判断用户是否存在**，存在则保存用户信息到redis中（生成随机uuid）；否则转到登陆界面或直接创建新用户
3. 之后用户再次登陆，后端则根据cookie中保存的sessionid获取用户信息，若有则放行
在登陆业务中，要从session中分离出来的数据有 验证码、用户信息、token（用于）。
- key-手机号（与验证码唯一对应的就行），value-验证码
- key-"login:code"（使用业务逻辑来命名），value-用户信息
<br/><br/><br/>



## 1.2 缓存更新策略
1. 内存淘汰，也就是redis自己管理。适合 一致性要求低，变化不大的数据。如首页模块的类型（一般都是什么外卖、超市、药店什么的）  
2. 超时剔除，手动设置超时时间  
3. 主动更新，即在数据库修改的同时更新缓存，同时用超时方案兜底。适合 一致性要求高的业务。如店铺详情的缓存  

### 商户缓存更新
由于商户信息的即时性要求不高，所以使用先改库再删缓存的方式更新数据。（延时双删也行）
<br/><br/><br/>



## 1.3 多线程安全问题
集群问题：
1. 多线程的每个线程都拥有自己的锁监视器，导致锁不共享，它们应该使用共同的锁才能避免超买。解决方案：使用redis的setnx锁。setIfAbsent（也就是setnx）根据key表示不同的锁，每个用户秒杀的商品 在redis中都拥有唯一的锁。
2. 误删问题：拥有锁的线程挂掉或者执行花费了太长的时间 导致redis自动把锁删了——如果这时候其它线程获取了锁而当前线程释放了锁，就会出现锁误删。解决方案：value表示拥有锁的线程（uuid+线程id），不是该value的线程不能释放锁，这样就避免了锁误删。
3. 误删问题：2判断条件通过后，线程阻塞了。解决：使用lua脚本实现判断和删除数据的原子性。
<br/><br/><br/>